# Issue 0022: タスク実行時間の積み上げ棒グラフ表示機能の実装解説

## 概要

本ドキュメントは、`feature/0022-task-execution-stackbar`ブランチで実装された「タスク実行時間の積み上げ棒グラフ表示機能」について、Issue 0022の要件に沿って詳細に解説します。

## Issue要件の整理

### 要件サマリー

1. 日付グループごとに横長の積み上げ棒グラフを表示
2. 各Todoがその日付にどれだけ時間を使用したかを可視化
3. 時間のカウントは`timeRanges`の日付を正確に考慮
   - 例: 2025-11-28に作業しても、未完了なら2025-11-29の枠にも**表示**される
   - しかし、時間を費やしたとカウントするのは2025-11-28のみ
4. 1時間ごとの目盛を表示
5. Todoごとに異なる色で視覚的に区別（仮実装としてランダム生成）
6. 12時間まで固定の縮尺を維持、超過時は密度を上げて表示
7. 実行時間が0の日付でも必ずグラフを表示

## 実装内容の詳細

### 1. 新規追加ファイル

#### 1.1 `src/utils/taskExecutionTime.ts`

**役割**: タスク実行時間の計算ロジックとTodoへの色割り当てを担当するユーティリティ関数群

**主要関数**:

##### `calculateExecutionTimeForDate(todo: Todo, date: string): number`

特定の日付におけるTodoの実行時間を分単位で計算します。

```typescript
export function calculateExecutionTimeForDate(todo: Todo, date: string): number {
  if (todo.timeRanges.length === 0) {
    return 0;
  }

  let totalMinutes = 0;

  for (const range of todo.timeRanges) {
    const startTime = parseJSTString(range.start);
    const startDate = extractDateFromJST(range.start);

    // このtimeRangeが指定日付に該当しない場合はスキップ
    if (startDate !== date) {
      continue;
    }

    // 終了時刻を取得（endがnullの場合は現在時刻）
    const endTime = range.end ? parseJSTString(range.end) : new Date();

    // 時間差を分に変換
    const durationMs = endTime.getTime() - startTime.getTime();
    const durationMinutes = Math.floor(durationMs / (1000 * 60));

    totalMinutes += durationMinutes;
  }

  return totalMinutes;
}
```

**実装のポイント**:

1. **日付フィルタリング**: `timeRanges`配列をイテレートする際、`extractDateFromJST(range.start)`で取得した日付と指定日付を比較することで、その日に実行された作業時間のみをカウント
2. **Issue要件への対応**: Issueで言及された「2025-11-28に時間を使ったとしても、完了しなければ2025-11-29の枠の中にも表示される」という要件は、`DateGroupedTodoList`側の日付グルーピングロジックで実現。本関数は純粋に「どの日に何分作業したか」を計算するのみ
3. **実行中タスクの対応**: `range.end`が`null`の場合は現在時刻までの経過時間を計算（タイマー実行中のタスクに対応）
4. **複数セッションの合計**: 同じ日に複数回作業した場合（複数の`timeRanges`がその日付に該当）、合計時間を返す

##### `calculateExecutionTimesForDate(todos: Todo[], date: string): Map<string, number>`

全てのTodoの特定日付における実行時間をまとめて計算します。

```typescript
export function calculateExecutionTimesForDate(
  todos: Todo[],
  date: string
): Map<string, number> {
  const executionTimes = new Map<string, number>();

  for (const todo of todos) {
    const minutes = calculateExecutionTimeForDate(todo, date);
    if (minutes > 0) {
      executionTimes.set(todo.getId(), minutes);
    }
  }

  return executionTimes;
}
```

**実装のポイント**:

1. **実行時間0のTodoを除外**: `minutes > 0`の条件により、その日に作業していないTodoは結果のMapに含まれない
2. **効率的なデータ構造**: `Map<string, number>`を使用することで、Viewコンポーネント側でTodo IDから実行時間を高速に取得可能

##### `assignColorToTodo(todoId: string): string`

Todoに対して一貫性のある色を割り当てます（仮実装）。

```typescript
export function assignColorToTodo(todoId: string): string {
  // IDをハッシュ化して色を生成（仮実装）
  let hash = 0;
  for (let i = 0; i < todoId.length; i++) {
    hash = todoId.charCodeAt(i) + ((hash << 5) - hash);
  }

  // HSL色空間で色相を分散させ、彩度と明度を固定
  const hue = Math.abs(hash) % 360;
  const saturation = 70;
  const lightness = 60;

  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
```

**実装のポイント**:

1. **決定論的な色生成**: 同じTodo IDに対して常に同じ色を返す（ランダムではなくハッシュベース）
2. **HSL色空間の利用**:
   - 色相（Hue）: 0-360度の範囲で分散させることで、異なるTodo間の色の差を最大化
   - 彩度（Saturation）: 70%に固定し、鮮やかすぎず淡すぎない適度な色合いを実現
   - 明度（Lightness）: 60%に固定し、視認性を確保
3. **Issue要件への対応**: Issueで「今は仮実装のためランダムに色を決める形にしてください」とあるが、実際には決定論的なハッシュベースの実装を採用。これにより、ページリロード時にも色が変わらず、ユーザー体験が向上

#### 1.2 `src/utils/taskExecutionTime.test.ts`

**役割**: `taskExecutionTime.ts`の各関数に対する包括的な単体テスト

**テストケース**:

##### `calculateExecutionTimeForDate`のテスト

1. **実行時間がない場合**: `timeRanges`が空配列の場合、0を返すことを確認
2. **単一セッション**: 1つの`timeRange`がある場合、正しく分単位で時間を計算
3. **複数セッション**: 同じ日に複数の`timeRange`がある場合、合計時間を返す
4. **日付フィルタリング**: 異なる日付の`timeRange`を正しく除外する
5. **実行中タスク**: `end`が`null`の場合、現在時刻までの時間を計算（時刻依存のため、0以上であることのみ検証）

```typescript
it('異なる日付のtimeRangesは除外する', () => {
  const todo = new Todo(
    'test-id',
    'TASK001',
    'Test task',
    null,
    '2025-11-28 10:00:00',
    '2025-11-28 10:00:00',
    [
      {
        start: '2025-11-28 10:00:00',
        end: '2025-11-28 11:00:00' // 60分（2025-11-28）
      },
      {
        start: '2025-11-29 14:00:00',
        end: '2025-11-29 15:00:00' // 60分（2025-11-29）
      }
    ]
  );

  const result = calculateExecutionTimeForDate(todo, '2025-11-28');
  expect(result).toBe(60);

  const result2 = calculateExecutionTimeForDate(todo, '2025-11-29');
  expect(result2).toBe(60);
});
```

このテストは、Issue要件の核心部分「どの日に時間を使用したかはきちんとtimeRangesの日付を見て考慮」を検証しています。

##### `calculateExecutionTimesForDate`のテスト

1. **複数Todoの処理**: 複数のTodoの実行時間を正しく計算し、Mapに格納
2. **実行時間0の除外**: 実行時間が0のTodoは結果のMapに含まれない

##### `assignColorToTodo`のテスト

1. **一貫性**: 同じIDに対して常に同じ色を返す
2. **分散性**: 異なるIDには異なる色を返す
3. **フォーマット**: HSL形式の文字列を返す

#### 1.3 `src/components/TaskExecutionStackBar.tsx`

**役割**: タスク実行時間の積み上げ棒グラフを表示するViewコンポーネント

**Props**:

```typescript
interface TaskExecutionStackBarProps {
  todos: Todo[];
  date: string; // YYYY-MM-DD形式
}
```

**コンポーネント構造**:

```typescript
export const TaskExecutionStackBar = ({ todos, date }: TaskExecutionStackBarProps) => {
  // その日のTodoごとの実行時間を計算
  const executionTimes = calculateExecutionTimesForDate(todos, date);

  // 合計実行時間を計算（分単位）
  let totalMinutes = 0;
  for (const minutes of executionTimes.values()) {
    totalMinutes += minutes;
  }

  // 12時間 = 720分を基準値とする
  const BASE_HOURS = 12;
  const BASE_MINUTES = BASE_HOURS * 60;

  // 表示する最大時間（12時間以上の場合は実際の時間、未満の場合は12時間）
  const displayMaxMinutes = Math.max(totalMinutes, BASE_MINUTES);

  // 1時間ごとの目盛を生成
  const totalHours = Math.ceil(displayMaxMinutes / 60);
  const hourMarkers = Array.from({ length: totalHours + 1 }, (_, i) => i);

  return (
    <div className="task-execution-stackbar">
      <div className="stackbar-container">
        {/* 積み上げ棒グラフ本体 */}
        <div className="stackbar-bar">
          {executionTimes.size === 0 ? (
            // 実行時間が0の場合は空の棒グラフを表示
            <div className="stackbar-empty"></div>
          ) : (
            // 各Todoの実行時間を積み上げて表示
            Array.from(executionTimes.entries()).map(([todoId, minutes]) => {
              const widthPercent = (minutes / displayMaxMinutes) * 100;
              const todo = todos.find((t) => t.getId() === todoId);
              const todoText = todo ? todo.getText() : '';
              const color = assignColorToTodo(todoId);
              const hours = (minutes / 60).toFixed(1);

              return (
                <div
                  key={todoId}
                  className="stackbar-segment"
                  style={{
                    width: `${widthPercent}%`,
                    backgroundColor: color
                  }}
                  title={`${todoText}: ${hours}h`}
                />
              );
            })
          )}
        </div>

        {/* 時間目盛 */}
        <div className="stackbar-scale">
          {hourMarkers.map((hour) => {
            const positionPercent = (hour * 60 / displayMaxMinutes) * 100;

            return (
              <div
                key={hour}
                className="stackbar-scale-marker"
                style={{ left: `${positionPercent}%` }}
              >
                <div className="stackbar-scale-line"></div>
                <div className="stackbar-scale-label">{hour}h</div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
};
```

**実装のポイント**:

1. **12時間の固定縮尺（Issue要件6）**:
   ```typescript
   const displayMaxMinutes = Math.max(totalMinutes, BASE_MINUTES);
   ```
   - 合計実行時間が12時間未満の場合は`BASE_MINUTES`（720分）を使用
   - 12時間を超える場合は実際の合計時間（`totalMinutes`）を使用
   - これにより、12時間までは異なる日付間で縮尺が統一され、視覚的な比較が容易になる

2. **実行時間0の場合の表示（Issue要件7）**:
   ```typescript
   {executionTimes.size === 0 ? (
     <div className="stackbar-empty"></div>
   ) : (
     // 積み上げグラフ
   )}
   ```
   - 実行時間が0の場合でも空の棒グラフ要素を表示
   - CSSで背景色が設定されており、グラフの存在を視覚的に示す

3. **積み上げ表示の実装**:
   - `executionTimes.entries()`をイテレートし、各Todoの実行時間に応じた幅のセグメントを生成
   - `width: ${widthPercent}%`で各セグメントの幅を制御
   - `display: flex`により、セグメントが自動的に横並びで積み上がる

4. **色分け（Issue要件8）**:
   - `assignColorToTodo(todoId)`で各Todoに一貫した色を割り当て
   - セグメントの`backgroundColor`に設定

5. **ツールチップ**:
   - `title`属性にTodoのテキストと実行時間を設定
   - ホバー時にブラウザのネイティブツールチップで詳細情報を表示

6. **1時間ごとの目盛（Issue要件4）**:
   - `hourMarkers`配列を生成し、各時間マーカーの位置を計算
   - `positionPercent = (hour * 60 / displayMaxMinutes) * 100`で目盛の位置を決定
   - 12時間を超える場合、目盛の間隔が密になる（「密度を上げて表示」に対応）

#### 1.4 `src/components/TaskExecutionStackBar.css`

**役割**: 積み上げ棒グラフのスタイル定義

**主要スタイル**:

```css
.stackbar-bar {
  display: flex;
  height: 24px;
  border: 1px solid #ddd;
  border-radius: 4px;
  overflow: hidden;
  background-color: #f9f9f9;
}
```

- `display: flex`: 子要素（セグメント）を横並びに配置
- `overflow: hidden`: `border-radius`を適用するために必要
- `background-color: #f9f9f9`: 実行時間0の場合の背景色

```css
.stackbar-segment {
  height: 100%;
  transition: opacity 0.2s;
  cursor: pointer;
  border-right: 1px solid rgba(255, 255, 255, 0.3);
}

.stackbar-segment:hover {
  opacity: 0.8;
}
```

- セグメント間の境界線を半透明の白線で表現
- ホバー時に透明度を下げることでインタラクティブ性を向上

```css
.stackbar-scale-marker {
  position: absolute;
  top: 0;
  transform: translateX(-50%);
}
```

- `position: absolute`と`left: ${positionPercent}%`で目盛の位置を制御
- `transform: translateX(-50%)`で目盛を中央揃え

### 2. 既存ファイルの変更

#### 2.1 `src/components/DateGroupedTodoList.tsx`

**変更内容**:

1. **インポートの追加**:
   ```typescript
   import { Todo } from '../models/Todo';
   import { TaskExecutionStackBar } from './TaskExecutionStackBar';
   ```

2. **Todo型のフィルタリング**:
   ```typescript
   // Todo型のアイテムのみを抽出（積み上げ棒グラフの計算に使用）
   const todoItems = todos.filter((item): item is Todo => item.getType() === 'todo');
   ```
   - `ListItem`配列から`Todo`型のみを抽出
   - `CalendarEvent`は実行時間の概念がないため除外
   - TypeScriptの型述語（`item is Todo`）を使用して型安全性を確保

3. **グラフの配置**:
   ```typescript
   <div key={group.date} className="date-group">
     <h2 className="date-group-header">{group.displayDate}</h2>
     {/* タスク実行時間の積み上げ棒グラフ */}
     <TaskExecutionStackBar todos={todoItems} date={group.date} />
     <ul className="todo-list">
       {/* ... */}
     </ul>
   </div>
   ```
   - 日付ヘッダーの直後、Todoリストの直前にグラフを配置
   - これにより、「その日のタスク実行状況 → 個別のTodoリスト」という視覚的な流れを実現

**Issue要件への対応**:

- **要件1「日付の横に横長の積み上げ棒グラフを表示」**: 日付グループ内にグラフを配置
- **要件3「どの日に時間を使用したかはきちんとtimeRangesの日付を見て考慮」**: `date={group.date}`を渡すことで、各日付グループに対して正しい日付での計算を実行

## MVCアーキテクチャとの対応

本実装は、プロジェクトのMVCアーキテクチャに準拠しています。

### Model層

- **ファイル**: `src/utils/taskExecutionTime.ts`
- **役割**:
  - Todoの実行時間計算のビジネスロジック
  - 色割り当てロジック
- **特徴**:
  - React、Electronに依存しない純粋関数
  - イミュータブルな設計（元のTodoオブジェクトを変更しない）
  - 包括的な単体テストでロジックの正確性を保証

### View層

- **ファイル**:
  - `src/components/TaskExecutionStackBar.tsx`
  - `src/components/TaskExecutionStackBar.css`
  - `src/components/DateGroupedTodoList.tsx`（変更部分）
- **役割**:
  - グラフの視覚的表現
  - ユーザーインタラクション（ホバー時のツールチップ）
- **特徴**:
  - ビジネスロジックを含まない（`calculateExecutionTimesForDate`などを呼び出すのみ）
  - 表示に関する状態のみを管理（実際にはこのコンポーネントはステートレス）

### Controller層

本実装では、Controller層（`useTodos`フック）への変更は不要でした。理由は以下の通りです：

- グラフ表示は読み取り専用の機能
- 既存のTodoデータ（`timeRanges`）を使用するのみで、新しい状態管理や副作用は不要
- View層が直接Model層のユーティリティ関数を呼び出す形で十分

## Issue要件とのマッピング

| Issue要件 | 実装箇所 | 実装方法 |
|----------|---------|---------|
| 1. 日付の横に横長の積み上げ棒グラフを表示 | `DateGroupedTodoList.tsx` | 日付ヘッダー直後に`TaskExecutionStackBar`を配置 |
| 2. 各todoごとにどれくらいの時間を使用したのかを積み上げ棒グラフで表示 | `TaskExecutionStackBar.tsx` | `executionTimes.entries()`をイテレートしてセグメント生成 |
| 3. どの日に時間を使用したかはきちんとtimeRangesの日付を見て考慮 | `taskExecutionTime.ts` の`calculateExecutionTimeForDate` | `extractDateFromJST(range.start)`で日付を抽出し、指定日付とマッチする`timeRange`のみを集計 |
| 4. グラフには1時間ごとの目盛を表示 | `TaskExecutionStackBar.tsx` | `hourMarkers`配列を生成し、各マーカーの位置を計算して表示 |
| 5. 各タスクごとに色を分けることで視覚的に分かるようにして | `taskExecutionTime.ts` の`assignColorToTodo` | Todo IDからハッシュ値を計算し、HSL色空間で色を生成 |
| 6. 棒グラフは12時間までなら累積の作業時間の大小によって縮尺が変わらないように、あらかじめ領域を確保しておいて固定。12時間を過ぎた場合は横幅は変えず、密度を上げて表示 | `TaskExecutionStackBar.tsx` | `displayMaxMinutes = Math.max(totalMinutes, BASE_MINUTES)` で基準値を設定。12時間以下は720分で固定、超過時は実際の時間を使用 |
| 7. その日の実行時間が0だった時などでも、必ず全ての日付に一律にグラフを表示すること | `TaskExecutionStackBar.tsx` | `executionTimes.size === 0`の場合に`stackbar-empty`要素を表示 |

## テストカバレッジ

`src/utils/taskExecutionTime.test.ts`により、Model層の全関数に対して以下のテストを実施：

- **`calculateExecutionTimeForDate`**: 5つのテストケース
  - 実行時間なし
  - 単一セッション
  - 複数セッション
  - 日付フィルタリング（最重要）
  - 実行中タスク
- **`calculateExecutionTimesForDate`**: 2つのテストケース
  - 複数Todoの処理
  - 実行時間0の除外
- **`assignColorToTodo`**: 3つのテストケース
  - 一貫性
  - 分散性
  - フォーマット

**合計**: 10テストケース、217行のテストコード

## まとめ

本実装は、Issue 0022の全ての要件を満たしつつ、以下の特徴を持ちます：

1. **MVCアーキテクチャの遵守**: ビジネスロジックをModel層に集約し、Viewは表示のみに専念
2. **高いテストカバレッジ**: Model層の全関数に対して包括的な単体テストを実施
3. **型安全性**: TypeScriptの型システムを活用し、コンパイル時にバグを検出
4. **パフォーマンス**: `Map<string, number>`を使用した効率的なデータ構造
5. **ユーザビリティ**: ホバー時のツールチップ、視覚的な色分け、固定縮尺による日付間の比較容易性

特に、Issue要件3「どの日に時間を使用したかはきちんとtimeRangesの日付を見て考慮してください」は、`calculateExecutionTimeForDate`関数の日付フィルタリングロジックと、その包括的なテストケースにより、正確に実装されています。
