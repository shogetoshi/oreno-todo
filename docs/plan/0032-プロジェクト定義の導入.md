# Issue #0032: プロジェクト定義の導入 - 実装計画書

## Issue概要

プロジェクト定義をJSONで管理し、横棒グラフの色付けに利用する機能を実装します。

### 要求内容

1. **プロジェクト定義をJSONで作成**
   - プロジェクト定義は月ごとに設定される
   - プロジェクトに複数のtaskcodeを紐付ける
   - 各todoやカレンダーイベントのtaskcodeからプロジェクトを決定

2. **プロジェクト定義JSON編集ボタンを作成**
   - 既存のJSON編集機能（Todo JSON編集、タイムカードJSON編集）と同じパターン

3. **横棒グラフの色をプロジェクト色で表示**（まず実装する機能）
   - 稼働時間を表示する横棒グラフの色は、プロジェクト定義で設定された色を使用
   - 描画する日付を考慮して、該当月のプロジェクト定義を使用
   - 該当プロジェクトがない場合は灰色

4. **未使用フィールドの扱い**
   - `assign`、`keywords`、`quickTasks`などはエラーにならないようにするだけ
   - 情報を保持しなくて良い

### JSONフォーマット例

```json
{
  "2025-12": [
    {
      "projectcode": "ProjectA",
      "color": "red",
      "assign": 0.6,
      "taskcodes": [
        {
          "taskcode": "ProjectA",
          "keywords": ["ProjectA"],
          "quickTasks": ["ProjectA"]
        }
      ]
    }
  ]
}
```

## 既存コードの調査結果

### 1. JSON編集機能のパターン

既存のJSON編集機能は以下の実装パターンを使用しています（`App.tsx`を参照）：

**View層（App.tsx）**:
- JSON編集モーダルのローカル状態管理
- `handleOpenJsonEditor()`: 編集モーダルを開く
- `handleCloseJsonEditor()`: 編集モーダルを閉じる
- `handleSaveJson()`: JSON保存処理

**Controller層（useTimecard.ts）**:
- `replaceFromJson()`: JSONテキストからデータ全体を置き換える関数を提供

**Model層（TimecardRepository.ts）**:
- `fromJsonText()`: JSONテキストをパースしてエンティティに変換
- `toJsonText()`: エンティティをJSON文字列に変換

**IPC通信（electron/main.ts, electron/preload.ts, src/types/electron.d.ts）**:
- `load-timecard`: データ読み込み
- `save-timecard`: データ保存

### 2. 横棒グラフの実装箇所

**View層**: `src/components/TaskExecutionStackBar.tsx`
- 積み上げ棒グラフのUI表示
- 各セグメントに`backgroundColor: color`を設定

**Model層**: `src/utils/taskExecutionTime.ts`
- `assignColorToTodo()`: ListItemのIDから色を決定（現在はハッシュベース）
- `calculateStackBarDisplay()`: セグメント情報を計算し、`assignColorToTodo()`で色を割り当て

### 3. データの流れ

```
View (TaskExecutionStackBar)
  ↓
Model (calculateStackBarDisplay)
  ↓
Model (assignColorToTodo) ← ここを変更してプロジェクト定義から色を取得
```

## 実装内容

### 1. Model層：ProjectDefinitionエンティティとRepositoryの作成

**ファイル**: `src/models/ProjectDefinition.ts`

プロジェクト定義を表すエンティティクラスとリポジトリクラスを実装します。

```typescript
// プロジェクト定義のエンティティ
class ProjectDefinition {
  constructor(
    public readonly projectcode: string,
    public readonly color: string,
    public readonly taskcodes: string[]
  ) {}

  // JSONからインスタンスを生成
  static fromJSON(json: any): ProjectDefinition

  // JSON形式に変換
  toJSON(): any
}

// プロジェクト定義のコレクション管理
class ProjectDefinitionRepository {
  // 月別のプロジェクト定義マップ (例: "2025-12" -> ProjectDefinition[])
  constructor(
    public readonly definitions: Map<string, ProjectDefinition[]>
  ) {}

  // JSONテキストからインスタンスを生成
  static fromJsonText(jsonText: string): ProjectDefinitionRepository

  // JSON文字列に変換
  static toJsonText(repo: ProjectDefinitionRepository): string

  // 指定日付・taskcodeからプロジェクト色を取得
  static getColorForTaskcode(
    repo: ProjectDefinitionRepository,
    date: string,  // YYYY-MM-DD形式
    taskcode: string
  ): string | null

  // 空のリポジトリを生成
  static createEmpty(): ProjectDefinitionRepository
}
```

### 2. Model層：色の割り当てロジックの変更

**ファイル**: `src/utils/taskExecutionTime.ts`

`assignColorToTodo()`関数を変更し、プロジェクト定義から色を取得するようにします。

```typescript
// 現在の関数シグネチャ
export function assignColorToTodo(itemId: string): string

// 変更後の関数シグネチャ
export function assignColorToItem(
  item: ListItem,
  date: string,
  projectRepo: ProjectDefinitionRepository
): string

// 実装内容:
// 1. item.getTaskcode()でtaskcodeを取得
// 2. ProjectDefinitionRepository.getColorForTaskcode()で色を取得
// 3. 該当プロジェクトがない場合は灰色 (#808080) を返す
```

`calculateStackBarDisplay()`関数も変更し、プロジェクトリポジトリと日付を受け取るようにします。

```typescript
// 現在の関数シグネチャ
export function calculateStackBarDisplay(
  items: ListItem[],
  date: string
): StackBarDisplayConfig

// 変更後の関数シグネチャ
export function calculateStackBarDisplay(
  items: ListItem[],
  date: string,
  projectRepo: ProjectDefinitionRepository
): StackBarDisplayConfig

// 実装内容:
// segmentの作成時に、assignColorToItem()を使用して色を決定
```

### 3. Controller層：プロジェクト定義の状態管理

**ファイル**: `src/hooks/useProjectDefinitions.ts`（新規作成）

プロジェクト定義の読み込み・保存・状態管理を行うカスタムフックを実装します。

```typescript
export function useProjectDefinitions() {
  const [projectRepo, setProjectRepo] = useState<ProjectDefinitionRepository>(
    ProjectDefinitionRepository.createEmpty()
  );
  const [isLoading, setIsLoading] = useState(true);

  // 初回マウント時にデータをロード
  useEffect(() => {
    loadProjectDefinitions();
  }, []);

  // IPC経由でプロジェクト定義を読み込む
  const loadProjectDefinitions = async () => { ... }

  // IPC経由でプロジェクト定義を保存
  const saveProjectDefinitions = async (repo: ProjectDefinitionRepository) => { ... }

  // JSONテキストからプロジェクト定義を置き換え
  const replaceFromJson = async (jsonText: string) => { ... }

  return {
    projectRepo,
    isLoading,
    replaceFromJson
  };
}
```

### 4. View層：TaskExecutionStackBarの変更

**ファイル**: `src/components/TaskExecutionStackBar.tsx`

プロジェクトリポジトリを受け取り、`calculateStackBarDisplay()`に渡します。

```typescript
interface TaskExecutionStackBarProps {
  items: ListItem[];
  date: string;
  timecardData: TimecardData;
  projectRepo: ProjectDefinitionRepository; // 追加
}

export const TaskExecutionStackBar = ({
  items,
  date,
  timecardData,
  projectRepo // 追加
}: TaskExecutionStackBarProps) => {
  // プロジェクトリポジトリを渡す
  const displayConfig = calculateStackBarDisplay(items, date, projectRepo);

  // 以降は既存の実装と同じ
}
```

### 5. View層：プロジェクト定義JSON編集ボタンの追加

**ファイル**: `src/App.tsx`

既存のJSON編集機能と同様のパターンで実装します。

```typescript
function App() {
  const { projectRepo, replaceFromJson: replaceProjectFromJson } = useProjectDefinitions();

  // プロジェクト定義JSON編集モーダルを開く
  const handleOpenProjectJsonEditor = () => {
    setJsonText(ProjectDefinitionRepository.toJsonText(projectRepo));
    setJsonError('');
    setIsProjectJsonEditor(true); // 新しい状態フラグ
    setIsJsonEditorOpen(true);
  };

  // JSON保存処理に分岐を追加
  const handleSaveJson = async () => {
    if (isProjectJsonEditor) {
      await replaceProjectFromJson(jsonText);
    } else if (isTimecardJsonEditor) {
      // 既存のロジック
    } else {
      // 既存のロジック
    }
  };

  // UIに編集ボタンを追加
  return (
    <div className="control-buttons">
      <button onClick={handleOpenProjectJsonEditor}>
        プロジェクト定義JSON編集
      </button>
      {/* 既存のボタン */}
    </div>
  );
}
```

`DateGroupedTodoList`と`TaskExecutionStackBar`にプロジェクトリポジトリを渡すようにします。

```typescript
<DateGroupedTodoList
  projectRepo={projectRepo} // 追加
  // 既存のprops
/>

// DateGroupedTodoList内でTaskExecutionStackBarに渡す
<TaskExecutionStackBar
  projectRepo={projectRepo} // 追加
  // 既存のprops
/>
```

### 6. IPC通信の追加

**ファイル**: `src/types/electron.d.ts`

```typescript
export interface ElectronAPI {
  loadProjectDefinitions: () => Promise<any>;
  saveProjectDefinitions: (data: any) => Promise<{ success: boolean; error?: string }>;
  // 既存のAPI
}
```

**ファイル**: `electron/preload.ts`

```typescript
const electronAPI: ElectronAPI = {
  loadProjectDefinitions: () => ipcRenderer.invoke('load-project-definitions'),
  saveProjectDefinitions: (data) => ipcRenderer.invoke('save-project-definitions', data),
  // 既存のAPI
};
```

**ファイル**: `electron/main.ts`

```typescript
const projectDefinitionsPath = path.join(app.getPath('userData'), 'project-definitions.json');

// プロジェクト定義の読み込み
ipcMain.handle('load-project-definitions', async () => {
  try {
    const data = await fsPromises.readFile(projectDefinitionsPath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
      return {}; // ファイルが存在しない場合は空オブジェクト
    }
    // JSONパースエラー時はバックアップを作成（既存パターンと同じ）
    console.error('Failed to load project definitions:', error);
    return {};
  }
});

// プロジェクト定義の保存（アトミックな書き込み）
ipcMain.handle('save-project-definitions', async (_, data) => {
  const tempPath = `${projectDefinitionsPath}.tmp`;
  try {
    await fsPromises.writeFile(tempPath, JSON.stringify(data, null, 2), 'utf-8');
    await fsPromises.rename(tempPath, projectDefinitionsPath);
    return { success: true };
  } catch (error) {
    console.error('Failed to save project definitions:', error);
    // 一時ファイルのクリーンアップ
    try {
      await fsPromises.unlink(tempPath);
    } catch (unlinkError) {
      // クリーンアップ失敗は無視
    }
    return { success: false, error: String(error) };
  }
});
```

### 7. データ保存場所

プロジェクト定義は以下の場所に保存されます：

- macOS: `~/Library/Application Support/oreno-todo/project-definitions.json`
- Windows: `%APPDATA%/oreno-todo/project-definitions.json`
- Linux: `~/.config/oreno-todo/project-definitions.json`

## 実装順序

以下の順序で実装を進めます：

1. **Model層：ProjectDefinitionエンティティとRepositoryの作成**
   - `src/models/ProjectDefinition.ts`を作成
   - `ProjectDefinition`クラスと`ProjectDefinitionRepository`クラスを実装
   - ユニットテスト`src/models/ProjectDefinition.test.ts`を作成

2. **IPC通信の追加**
   - `src/types/electron.d.ts`にAPI定義を追加
   - `electron/preload.ts`にIPC呼び出しを追加
   - `electron/main.ts`にハンドラーを追加

3. **Controller層：プロジェクト定義の状態管理**
   - `src/hooks/useProjectDefinitions.ts`を作成

4. **Model層：色の割り当てロジックの変更**
   - `src/utils/taskExecutionTime.ts`の`assignColorToTodo()`を`assignColorToItem()`に変更
   - `calculateStackBarDisplay()`にプロジェクトリポジトリのパラメータを追加
   - ユニットテスト`src/utils/taskExecutionTime.test.ts`を更新

5. **View層：TaskExecutionStackBarの変更**
   - `src/components/TaskExecutionStackBar.tsx`にプロジェクトリポジトリのpropsを追加

6. **View層：プロジェクト定義JSON編集ボタンの追加**
   - `src/App.tsx`に編集ボタンとモーダル処理を追加
   - `src/components/DateGroupedTodoList.tsx`にプロジェクトリポジトリのpropsを追加

7. **統合テストと動作確認**
   - アプリケーションを起動し、JSON編集ボタンの動作を確認
   - プロジェクト定義を作成し、横棒グラフの色が反映されることを確認
   - 該当プロジェクトがない場合に灰色が表示されることを確認

## 考慮事項

### 1. 既存データとの互換性

- プロジェクト定義ファイルが存在しない場合は空のリポジトリを返す
- エラー時はバックアップを作成（既存パターンに従う）

### 2. 未使用フィールドの扱い

- `assign`、`keywords`、`quickTasks`、`projectname`などのフィールドはJSONパース時に無視される
- 将来の拡張に備えてJSONには含めるが、モデルには保持しない

### 3. 日付とプロジェクト定義の紐付け

- 日付（YYYY-MM-DD）から月（YYYY-MM）を抽出してプロジェクト定義を検索
- 該当月のプロジェクト定義が存在しない場合は、色をnullで返す

### 4. 色の指定方法

- JSONでは色名（"red", "pink", "orange"など）やhex形式（"#FF0000"）を受け付ける
- CSS colorとして有効な値であればそのまま使用
- 該当プロジェクトがない場合は灰色（`#808080`）

### 5. 複数のtaskcodeが同じプロジェクトに属する場合

- プロジェクト定義の`taskcodes`配列に複数のtaskcodeを含める
- `getColorForTaskcode()`は配列を線形探索して最初にマッチしたプロジェクトの色を返す

### 6. テスト戦略

- `ProjectDefinition`と`ProjectDefinitionRepository`のユニットテストを作成
- `assignColorToItem()`と`calculateStackBarDisplay()`のテストケースを追加
- 手動テスト：JSONファイルを直接編集して色が正しく反映されることを確認

## テスト項目

### ユニットテスト

- `ProjectDefinition.fromJSON()`：正常なJSON、不正なJSONのケース
- `ProjectDefinitionRepository.fromJsonText()`：複数月のデータを正しくパース
- `ProjectDefinitionRepository.getColorForTaskcode()`：
  - 該当するプロジェクトがある場合に色を返す
  - 該当するプロジェクトがない場合にnullを返す
  - 月が異なる場合にnullを返す
- `assignColorToItem()`：
  - プロジェクト定義から色を取得
  - 該当プロジェクトがない場合に灰色を返す
- `calculateStackBarDisplay()`：プロジェクト色が正しく割り当てられる

### 統合テスト

- JSON編集ボタンから定義を作成・保存できる
- 横棒グラフの色がプロジェクト定義に従って表示される
- 該当プロジェクトがない場合に灰色が表示される
- 異なる月の定義が正しく使い分けられる

## 注意事項

- **必要最小限の変更**: Issue #0032で要求された「横棒グラフの色をプロジェクト色で表示」のみを実装します。`assign`、`keywords`、`quickTasks`などの機能は将来の拡張のため、現時点では実装しません。
- **既存パターンの踏襲**: JSON編集機能、IPC通信、Repository Patternなど、既存のコードパターンに従います。
- **MVCアーキテクチャの遵守**: ビジネスロジックはModel層に集約し、Controller層は状態管理とIPC通信のみ、View層はUI表示のみを担当します。
- **イミュータブルな設計**: すべてのエンティティは変更不可とし、更新時は新しいインスタンスを返します。
- **テストの作成**: Model層のロジックには必ずユニットテストを作成します。
