# Issue #0030: 所要時間の表示が正常な値になっていない

## 問題の概要

todo・カレンダーイベントの所要時間表示が正常な値になっていない。観測範囲では、全て数字が0になっている。Issue #0025の仕様通りになるように修正する。

## Issue #0025の仕様（経過時間表示の改善）

各todoに表示されている消費時間の数値を`xx/yy`という表記に改善する。

### 通常のtodoの場合
- `xx`: その表示されている日付枠における消費時間（横棒グラフで利用する数値と一致）
- `yy`: そのTodoでの通算の消費時間（現在の実装で表示されている数値のまま）

### スケジュールイベント（CalendarEvent）の場合
- `xx`: `timeRanges`から算出される消費時間（日付枠における消費時間）
- `yy`: `startTime`, `endTime`から算出される時間

## バグの原因

### 1. 実装されていないメソッド

**`src/models/Todo.ts`の186-191行目:**
```typescript
/**
 * 指定日付における実行時間を分単位で取得する
 * @param date 日付（YYYY-MM-DD形式）
 * @returns 指定日付における実行時間（分）
 */
getExecutionTimeForDate(_date: string): number {
  // TODO: 実装
  // timeRangesをループし、指定日付のものだけを集計
  // extractDateFromJST, parseJSTStringを使用
  return 0;
}
```

**`src/models/CalendarEvent.ts`の217-226行目:**
```typescript
/**
 * 指定日付における実行時間を分単位で取得する
 * @param date 日付（YYYY-MM-DD形式）
 * @returns 指定日付における実行時間（分）
 */
getExecutionTimeForDate(_date: string): number {
  // TODO: 実装
  // timeRangesをループし、指定日付のものだけを集計
  // extractDateFromJST, parseJSTStringを使用
  return 0;
}
```

これらのメソッドは`ListItem`インターフェースで定義されており、`TodoItem.tsx`の39行目で呼び出されているが、実装が`return 0;`のままになっている。

### 2. 既存の実装との関係

既に`src/utils/taskExecutionTime.ts`の6-39行目に同じロジックの関数`calculateExecutionTimeForDate()`が実装されており、横棒グラフでは正常に動作している。

```typescript
export function calculateExecutionTimeForDate(item: ListItem, date: string): number {
  const timeRanges = item.getTimeRanges();
  if (timeRanges.length === 0) {
    return 0;
  }

  let totalMinutes = 0;

  for (const range of timeRanges) {
    const startTime = parseJSTString(range.start);
    const startDate = extractDateFromJST(range.start);

    // このtimeRangeが指定日付に該当しない場合はスキップ
    if (startDate !== date) {
      continue;
    }

    // 終了時刻を取得（endがnullの場合は現在時刻）
    const endTime = range.end ? parseJSTString(range.end) : new Date();

    // 時間差を分に変換
    const durationMs = endTime.getTime() - startTime.getTime();
    const durationMinutes = Math.floor(durationMs / (1000 * 60));

    totalMinutes += durationMinutes;
  }

  return totalMinutes;
}
```

この関数は`src/utils/taskExecutionTime.test.ts`で十分にテストされている。

### 3. 表示箇所

**`src/components/TodoItem.tsx`の38-40行目と150-152行目:**
```typescript
// TODO: 実装
const executionTimeForDate = todo.getExecutionTimeForDate(currentDate);
const totalExecutionTime = todo.getTotalExecutionTimeInMinutes();

// ... (中略) ...

<span className="execution-time">
  {executionTimeForDate}/{totalExecutionTime}
</span>
```

`executionTimeForDate`が常に0を返しているため、表示が`0/xx`となっている。

## 修正方針

### アプローチ

`Todo.getExecutionTimeForDate()`と`CalendarEvent.getExecutionTimeForDate()`の実装を完成させる。

既存の`calculateExecutionTimeForDate()`関数は外部から呼び出すユーティリティとして使用されているため、そのロジックを`Todo`と`CalendarEvent`のメソッド内に実装する。コードの重複になるが、以下の理由からこのアプローチを採用する:

1. **MVCアーキテクチャの遵守**: Model層（`Todo`/`CalendarEvent`）は外部ユーティリティに依存せず、自己完結したビジネスロジックを持つべき
2. **ListItemインターフェースの実装**: `getExecutionTimeForDate()`はインターフェースで定義されており、各エンティティが責任を持って実装すべき
3. **単体テスト容易性**: エンティティメソッドとして実装することで、`Todo.test.ts`と`CalendarEvent.test.ts`で独立してテスト可能

### 実装の詳細

#### 1. `Todo.getExecutionTimeForDate()`の実装

`src/models/Todo.ts`の186-191行目を以下のように実装する:

```typescript
getExecutionTimeForDate(date: string): number {
  if (this.timeRanges.length === 0) {
    return 0;
  }

  let totalMinutes = 0;

  for (const range of this.timeRanges) {
    const startDate = extractDateFromJST(range.start);

    // このtimeRangeが指定日付に該当しない場合はスキップ
    if (startDate !== date) {
      continue;
    }

    // 終了時刻を取得（endがnullの場合は現在時刻）
    const startTime = parseJSTString(range.start);
    const endTime = range.end ? parseJSTString(range.end) : parseJSTString(getCurrentJSTTime());

    // 時間差を分に変換
    const durationMs = endTime.getTime() - startTime.getTime();
    const durationMinutes = Math.floor(durationMs / (1000 * 60));

    totalMinutes += durationMinutes;
  }

  return totalMinutes;
}
```

#### 2. `CalendarEvent.getExecutionTimeForDate()`の実装

`src/models/CalendarEvent.ts`の217-226行目に同様のロジックを実装する。

#### 3. テストケースの追加

`src/models/Todo.test.ts`に以下のテストケースを追加:

```typescript
describe('getExecutionTimeForDate', () => {
  it('指定日付に実行時間がない場合は0を返す', () => {
    const todo = new Todo(
      'test-id',
      'TASK001',
      'Test task',
      null,
      '2025-11-28 10:00:00',
      '2025-11-28 10:00:00',
      []
    );

    const result = todo.getExecutionTimeForDate('2025-11-28');
    expect(result).toBe(0);
  });

  it('指定日付の実行時間を正しく計算する', () => {
    const todo = new Todo(
      'test-id',
      'TASK001',
      'Test task',
      null,
      '2025-11-28 10:00:00',
      '2025-11-28 10:00:00',
      [
        {
          start: '2025-11-28 10:00:00',
          end: '2025-11-28 11:30:00' // 90分
        }
      ]
    );

    const result = todo.getExecutionTimeForDate('2025-11-28');
    expect(result).toBe(90);
  });

  it('複数のtimeRangesがある場合は合計時間を返す', () => {
    const todo = new Todo(
      'test-id',
      'TASK001',
      'Test task',
      null,
      '2025-11-28 10:00:00',
      '2025-11-28 10:00:00',
      [
        {
          start: '2025-11-28 10:00:00',
          end: '2025-11-28 11:00:00' // 60分
        },
        {
          start: '2025-11-28 14:00:00',
          end: '2025-11-28 15:30:00' // 90分
        }
      ]
    );

    const result = todo.getExecutionTimeForDate('2025-11-28');
    expect(result).toBe(150);
  });

  it('異なる日付のtimeRangesは除外する', () => {
    const todo = new Todo(
      'test-id',
      'TASK001',
      'Test task',
      null,
      '2025-11-28 10:00:00',
      '2025-11-28 10:00:00',
      [
        {
          start: '2025-11-28 10:00:00',
          end: '2025-11-28 11:00:00' // 60分（2025-11-28）
        },
        {
          start: '2025-11-29 14:00:00',
          end: '2025-11-29 15:00:00' // 60分（2025-11-29）
        }
      ]
    );

    const result = todo.getExecutionTimeForDate('2025-11-28');
    expect(result).toBe(60);

    const result2 = todo.getExecutionTimeForDate('2025-11-29');
    expect(result2).toBe(60);
  });

  it('endがnullの場合は現在時刻までの時間を計算する', () => {
    // 固定時刻: 2025-01-15 12:34:56（vitest beforeEachで設定済み）
    const todo = new Todo(
      'test-id',
      'TASK001',
      'Test task',
      null,
      '2025-01-15 10:00:00',
      '2025-01-15 10:00:00',
      [
        {
          start: '2025-01-15 10:00:00',
          end: null
        }
      ]
    );

    // 10:00:00 から 12:34:56 まで = 154分
    const result = todo.getExecutionTimeForDate('2025-01-15');
    expect(result).toBe(154);
  });
});
```

同様のテストケースを`src/models/CalendarEvent.test.ts`にも追加する。

#### 4. コメント削除

`src/components/TodoItem.tsx`の38行目のコメント`// TODO: 実装`を削除する。

## 実装の影響範囲

### 変更ファイル

1. `src/models/Todo.ts`: `getExecutionTimeForDate()`メソッドの実装
2. `src/models/CalendarEvent.ts`: `getExecutionTimeForDate()`メソッドの実装
3. `src/models/Todo.test.ts`: テストケースの追加
4. `src/models/CalendarEvent.test.ts`: テストケースの追加
5. `src/components/TodoItem.tsx`: コメントの削除

### 変更しないファイル

- `src/utils/taskExecutionTime.ts`: 横棒グラフで使用されているため、変更しない
- `src/utils/taskExecutionTime.test.ts`: 既存のテストは維持
- `src/components/DateGroupedTodoList.tsx`: 横棒グラフの表示ロジックは変更不要

## テスト戦略

### 単体テスト

1. **`Todo.getExecutionTimeForDate()`のテスト**:
   - 実行時間がない場合: 0を返す
   - 単一timeRangeの場合: 正しく計算
   - 複数timeRangesの場合: 合計時間を計算
   - 異なる日付のtimeRanges: 除外される
   - endがnullの場合: 現在時刻までを計算

2. **`CalendarEvent.getExecutionTimeForDate()`のテスト**:
   - 同様のテストケース

3. **既存テストの実行**:
   - `src/utils/taskExecutionTime.test.ts`: 全テストが継続して成功することを確認

### 統合テスト（手動）

1. **通常のTodo**:
   - 新しいTodoを作成し、タイマーを開始・停止
   - 所要時間表示が`xx/yy`形式で正しく表示されることを確認
   - `xx`が横棒グラフの時間と一致することを確認

2. **CalendarEvent**:
   - Googleカレンダーからイベントをインポート
   - 完了状態にする（timeRangesに追加される）
   - 所要時間表示が`xx/yy`形式で正しく表示されることを確認

3. **複数日にまたがるTodo**:
   - 複数の日付でタイマーを開始・停止
   - 各日付の枠で正しい時間が表示されることを確認

## 実装手順

1. `src/models/Todo.ts`の`getExecutionTimeForDate()`メソッドを実装
2. `src/models/CalendarEvent.ts`の`getExecutionTimeForDate()`メソッドを実装
3. `src/models/Todo.test.ts`にテストケースを追加
4. `src/models/CalendarEvent.test.ts`にテストケースを追加
5. `src/components/TodoItem.tsx`のコメントを削除
6. 全テストを実行し、成功を確認
7. 手動で動作確認

## 期待される結果

### 修正前
```
所要時間表示: 0/120
```

### 修正後
```
所要時間表示: 90/120
```

- `90`: その日付における実行時間（横棒グラフと一致）
- `120`: 通算の実行時間

## 注意事項

1. **コードの重複について**:
   - `calculateExecutionTimeForDate()`と`Todo.getExecutionTimeForDate()`で同じロジックが重複するが、これはMVCアーキテクチャの分離を維持するための意図的な設計
   - 将来的にリファクタリングが必要な場合は、共通ロジックを抽出することも検討可能

2. **後方互換性**:
   - `ListItem`インターフェースは変更しない
   - 既存のJSON形式は変更しない
   - 外部APIの動作は変更しない

3. **パフォーマンス**:
   - 各Todoアイテムの表示時に`getExecutionTimeForDate()`が呼び出されるため、timeRangesが大量にある場合はパフォーマンスに影響する可能性がある
   - 現状のユースケースでは問題ないと判断

## 参考資料

- Issue #0025: 経過時間表示の改善
- Issue #0030: 所用時間の表示が会っていない
- `src/utils/taskExecutionTime.ts`: 既存の実装
- `src/utils/taskExecutionTime.test.ts`: 既存のテスト
- `docs/MVC-ARCHITECTURE.md`: MVCアーキテクチャ設計書
