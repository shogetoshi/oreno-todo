# Issue 0046: 識別しやすい見た目

## Issue概要

各タスクの状態を視覚的にわかりやすくする。以下の3つの状態を容易に見分けられるようにする:

1. **今実行中かどうか** (タイマー実行中の状態)
2. **完了済みかどうか**
3. **TodoとCalendarEventの違い** (アイテムタイプ)

さらに、すべての状態において**taskcodeを色で識別できるようにする**（プロジェクト定義に基づく色付け）。

## 現状の分析

### 現在の視覚表現

**TodoItem.tsx (136-139行目)**:
```tsx
style={{
  borderLeft: `20px solid ${projectColor}`,
  backgroundColor: colorToRgba(projectColor, 0.5),
  opacity: isDragging ? 0.5 : 1
}}
```

- 左ボーダー (20px) でプロジェクト色を表示
- 背景色はプロジェクト色の50%透明度
- ドラッグ中は全体の透明度を50%に

**完了済み状態 (App.css 186-188行目)**:
```css
.todo-item.completed {
  opacity: 0.6;
}
```

**タイマー実行中状態 (App.css 344-351行目)**:
```css
.timer-button.timer-running {
  color: #0d6efd;
  background: #cfe2ff;
}
```

### 課題

1. **タイマー実行中の視認性が低い**: タイマーボタンの色変化のみで、アイテム全体での視覚的な強調が不足
2. **完了済みの視認性**: opacity 0.6だけでは、taskcodeの色が見えづらくなる
3. **TodoとCalendarEventの区別**: 現状ではアイテムタイプの視覚的な区別がない
4. **taskcodeの色識別**: 完了状態やタイマー実行中でもtaskcodeに対応する色を維持する必要がある

## 実装方針

### 1. View層の拡張 (TodoItem.tsx)

**目的**: アイテムの状態に応じた視覚的な強調表現を追加

**変更内容**:
- `getItemVisualStyle()` 関数を追加: アイテムの状態（実行中、完了済み、タイプ）に基づいて動的にスタイルを計算
- 状態に応じたクラス名を追加: `timer-running`, `calendar-event`

**スタイル計算ロジック**:
```typescript
function getItemVisualStyle(
  todo: ListItem,
  projectColor: string,
  isDragging: boolean
): React.CSSProperties
```

この関数は以下の優先順位で視覚スタイルを決定:
1. **タイマー実行中**: 強い視覚的強調（アニメーション、太いボーダー、明るい背景）
2. **完了済み**: 控えめな表示（薄い背景、細いボーダー、strikethrough）
3. **CalendarEvent**: アイコン表示でタイプを識別
4. **通常のTodo**: デフォルトスタイル

すべての状態でtaskcodeの色（左ボーダー）は維持される。

### 2. CSS拡張 (App.css)

**タイマー実行中の視覚強調**:
- `.todo-item.timer-running` クラスを追加
- 左ボーダーを太く (20px → 30px)
- パルスアニメーション追加
- 背景色を明るく（projectColorの70%透明度）
- 軽いドロップシャドウ追加

**完了済みアイテム**:
- 既存の`.todo-item.completed`を調整
- taskcodeの色は維持しつつ、全体的に控えめに

**CalendarEvent識別**:
- `.todo-item.calendar-event` クラスを追加
- カレンダーアイコン（📅）をpseudo-element (`::before`) で表示
- 右上に小さくアイコン配置

**アニメーション定義**:
```css
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.02); }
}
```

### 3. Model層への影響

**変更不要**: この実装はView層の視覚表現のみを変更するため、Model層のロジックには影響しない。

既存のメソッドを利用:
- `ListItem.isTimerRunning()`: タイマー実行中判定
- `ListItem.isCompleted()`: 完了判定
- `ListItem.getType()`: アイテムタイプ取得
- `assignColorToItem()`: プロジェクト色取得

## 実装の詳細

### View層の変更

**ファイル**: `src/components/TodoItem.tsx`

1. **スタイル計算関数の追加** (ファイル先頭):
   ```typescript
   function getItemVisualStyle(
     todo: ListItem,
     projectColor: string,
     isDragging: boolean
   ): React.CSSProperties {
     const isRunning = todo.isTimerRunning();
     const isCompleted = todo.isCompleted();

     // タイマー実行中の強調スタイル
     if (isRunning) {
       return {
         borderLeft: `30px solid ${projectColor}`,
         backgroundColor: colorToRgba(projectColor, 0.7),
         opacity: isDragging ? 0.5 : 1,
         boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
       };
     }

     // 完了済みの控えめなスタイル
     if (isCompleted) {
       return {
         borderLeft: `15px solid ${projectColor}`,
         backgroundColor: colorToRgba(projectColor, 0.3),
         opacity: isDragging ? 0.5 : 0.6,
       };
     }

     // デフォルトスタイル
     return {
       borderLeft: `20px solid ${projectColor}`,
       backgroundColor: colorToRgba(projectColor, 0.5),
       opacity: isDragging ? 0.5 : 1,
     };
   }
   ```

2. **クラス名の動的生成**:
   ```typescript
   const itemClassName = [
     'todo-item',
     completed && 'completed',
     isTimerRunning && 'timer-running',
     todo.getType() === ListItemType.CALENDAR_EVENT && 'calendar-event',
   ].filter(Boolean).join(' ');
   ```

3. **JSX要素の更新**:
   ```tsx
   <li
     className={itemClassName}
     style={getItemVisualStyle(todo, projectColor, isDragging)}
     // ... 他のprops
   >
   ```

### CSS層の変更

**ファイル**: `src/App.css`

1. **タイマー実行中のスタイル追加** (既存の`.todo-item`の後):
   ```css
   .todo-item.timer-running {
     animation: pulse 2s ease-in-out infinite;
   }

   @keyframes pulse {
     0%, 100% {
       transform: scale(1);
       box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
     }
     50% {
       transform: scale(1.02);
       box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
     }
   }
   ```

2. **CalendarEventアイコン追加** (既存の`.todo-item`の後):
   ```css
   .todo-item.calendar-event::before {
     content: '📅';
     position: absolute;
     top: 8px;
     right: 8px;
     font-size: 18px;
     opacity: 0.7;
   }

   .todo-item {
     position: relative; /* ::before要素のため */
   }
   ```

3. **完了状態の調整** (既存の`.todo-item.completed`を更新):
   ```css
   .todo-item.completed {
     /* opacity: 0.6; は削除（getItemVisualStyleで管理） */
   }
   ```

## 考慮事項

### 視認性の優先順位

1. **最優先**: タイマー実行中のアイテム（ユーザーが今作業中のタスク）
2. **次点**: 未完了のアイテム（今後作業するタスク）
3. **低優先**: 完了済みのアイテム（履歴）

### アクセシビリティ

- 色だけに依存せず、アニメーション、サイズ、アイコンも組み合わせる
- 十分なコントラスト比を維持
- 完了済みアイテムも最低限の視認性を確保

### パフォーマンス

- CSS animationは`transform`と`box-shadow`のみを使用（GPU加速）
- アニメーションは実行中アイテムのみに適用
- リフローを最小限に抑える

### 既存機能への影響

- ドラッグ&ドロップ: 既存の`isDragging`による透明度変更を維持
- ダブルクリック編集: 既存の動作を維持
- プロジェクト色: すべての状態でtaskcode色を保持

## テスト観点

1. **タイマー実行中の視覚確認**:
   - タイマー開始時にアイテムが強調表示されるか
   - パルスアニメーションが動作するか
   - 左ボーダーが太くなるか

2. **完了済みの視覚確認**:
   - 完了時にアイテムが控えめになるか
   - taskcode色が維持されているか
   - strikethroughが適用されるか

3. **CalendarEvent識別**:
   - CalendarEventに📅アイコンが表示されるか
   - アイコンの位置が適切か

4. **複合状態のテスト**:
   - 完了済み + CalendarEvent
   - タイマー実行中 + Todo
   - ドラッグ中の各状態

5. **プロジェクト色の維持**:
   - すべての状態でtaskcodeに対応する色が左ボーダーに表示されるか
   - 色のない（灰色）アイテムも正しく表示されるか

## ファイル変更サマリー

- `src/components/TodoItem.tsx`: スタイル計算関数追加、クラス名動的生成
- `src/App.css`: `.timer-running`, `.calendar-event`クラス追加、アニメーション定義
- テストファイル: 変更不要（視覚的な確認が中心）
