# Issue 0034: 稼働時間表示修正 - 実装計画

## 要件

- 稼働時間表示（赤い縦棒）を修正します。
    - タイムカードにstartが最後でendがない場合、現在時刻までの時間として計算して表示します。
    - ↑以外の形でstart/endの関係がおかしい場合は赤い棒自体を表示しないでください。
        - start/endが2個以上続いているなど
        - start, endの情報が一切ない状態も赤い棒自体を表示させない

## 現状分析

### 現在の実装箇所

1. **TaskExecutionStackBar.tsx (View層)**
   - Line 23: `TimecardRepository.calculateWorkingTimeForDate()`を呼び出して稼働時間を取得
   - Line 26-28: 稼働時間の位置をパーセンテージで計算
   - Line 79-86: 赤い縦棒を表示（常に表示される）

2. **TimecardRepository.ts (Model層)**
   - Line 195-224: `calculateWorkingTimeForDate()`メソッド
     - 現在の挙動: start-endのペアのみを集計し、ペアになっていないstartは無視
     - 問題点: 最後にstartがあってendがない場合、現在時刻までを計算していない

3. **TimecardRepository.test.ts**
   - Line 195-207: ペアになっていないstartは無視するテスト
   - 新しいテストケースが必要

### 問題点

1. **現在時刻までの計算が未実装**
   - 最後にstartがあってendがない場合、そのstart以降の時間が計算されていない

2. **異常パターンの検証が未実装**
   - start/endの順序が不正な場合の検証ロジックがない
   - 異常パターン時に赤い棒を非表示にするロジックがない

3. **常に赤い棒が表示される**
   - エントリが存在しない、または異常な場合でも赤い棒が表示される

## 実装方針

### MVCアーキテクチャに従った設計

**Model層 (TimecardRepository.ts)**:
- タイムカードのstart/endペアが正常かを検証する新メソッド `validateTimecardEntries()` を追加
- 稼働時間の計算ロジックを拡張（`calculateWorkingTimeForDate()`）
  - 最後がstartで終わっている場合は現在時刻までを計算
  - 異常パターンの場合は `null` を返す

**View層 (TaskExecutionStackBar.tsx)**:
- `calculateWorkingTimeForDate()`の戻り値を `number | null` に対応
- `null` の場合は赤い棒を表示しない

### 詳細設計

#### 1. エントリ検証ロジック（Model層）

`TimecardRepository.validateTimecardEntries()` メソッドを追加:

```typescript
/**
 * タイムカードエントリが正常なstart-endペアになっているかを検証する
 *
 * 正常なパターン:
 * - start, end, start, end, ... （完全なペア）
 * - start, end, start, end, ..., start （最後がstartで終わる）
 *
 * 異常なパターン:
 * - start, start, ... （startが連続）
 * - end, ... （endから始まる）
 * - start, end, end, ... （endが連続）
 * - 空配列 （エントリなし）
 *
 * @param entries タイムカードエントリ配列
 * @returns true: 正常、false: 異常
 */
static validateTimecardEntries(entries: TimecardEntry[]): boolean {
  if (entries.length === 0) {
    return false;
  }

  let expectingStart = true;

  for (const entry of entries) {
    if (expectingStart && entry.type !== 'start') {
      return false; // startを期待しているのにendが来た
    }
    if (!expectingStart && entry.type !== 'end') {
      return false; // endを期待しているのにstartが来た
    }
    expectingStart = !expectingStart;
  }

  return true;
}
```

#### 2. 稼働時間計算ロジックの拡張（Model層）

`calculateWorkingTimeForDate()` メソッドを修正:

```typescript
/**
 * 指定日付の稼働時間を分単位で計算する
 *
 * - 正常なstart-endペアの場合: 各ペアの時間差を合計
 * - 最後がstartで終わる場合: 最後のstartから現在時刻までを含めて計算
 * - 異常なパターンの場合: null を返す
 *
 * @param data タイムカードデータ
 * @param date 日付（YYYY-MM-DD形式）
 * @returns 稼働時間（分）、または異常時は null
 */
static calculateWorkingTimeForDate(data: TimecardData, date: string): number | null {
  const entries = data[date] || [];

  // エントリの検証
  if (!this.validateTimecardEntries(entries)) {
    return null;
  }

  let totalMinutes = 0;
  let currentStartEntry: TimecardEntry | null = null;

  for (const entry of entries) {
    if (entry.type === 'start') {
      currentStartEntry = entry;
    } else if (entry.type === 'end' && currentStartEntry !== null) {
      const startTime = new Date(currentStartEntry.time);
      const endTime = new Date(entry.time);
      const diffMs = endTime.getTime() - startTime.getTime();
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      totalMinutes += diffMinutes;
      currentStartEntry = null;
    }
  }

  // 最後がstartで終わっている場合、現在時刻までを計算
  if (currentStartEntry !== null) {
    const startTime = new Date(currentStartEntry.time);
    const now = new Date();
    const diffMs = now.getTime() - startTime.getTime();
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    totalMinutes += diffMinutes;
  }

  return totalMinutes;
}
```

#### 3. View層の修正（TaskExecutionStackBar.tsx）

赤い棒の表示条件を追加:

```typescript
// タイムカードから稼働時間を計算
const workingTimeMinutes = TimecardRepository.calculateWorkingTimeForDate(timecardData, date);

// 稼働時間がnullの場合（異常パターン）は赤い棒を表示しない
const shouldShowWorkingTimeLine = workingTimeMinutes !== null;

// 稼働時間の位置をパーセンテージで計算
const workingTimePositionPercent = shouldShowWorkingTimeLine && displayConfig.displayMaxMinutes > 0
  ? (workingTimeMinutes / displayConfig.displayMaxMinutes) * 100
  : 0;

// JSX内:
{shouldShowWorkingTimeLine && (
  <div
    className="stackbar-working-time-marker"
    style={{ left: `${workingTimePositionPercent}%` }}
    title={`稼働時間: ${(workingTimeMinutes! / 60).toFixed(1)}h`}
  >
    <div className="stackbar-working-time-line"></div>
  </div>
)}
```

#### 4. テストケースの追加（TimecardRepository.test.ts）

以下のテストケースを追加:

```typescript
describe('validateTimecardEntries', () => {
  it('正常なstart-endペアの場合はtrueを返す', () => { ... });
  it('最後がstartで終わる場合はtrueを返す', () => { ... });
  it('空配列の場合はfalseを返す', () => { ... });
  it('startが連続する場合はfalseを返す', () => { ... });
  it('endから始まる場合はfalseを返す', () => { ... });
  it('endが連続する場合はfalseを返す', () => { ... });
});

describe('calculateWorkingTimeForDate - 拡張版', () => {
  it('最後がstartで終わる場合、現在時刻までを計算する', () => { ... });
  it('異常なパターンの場合、nullを返す', () => { ... });
  it('エントリが存在しない場合、nullを返す', () => { ... });
});
```

## 実装タスク

### タスク1: Model層 - 検証ロジックの実装

- ファイル: `src/models/TimecardRepository.ts`
- 内容: `validateTimecardEntries()` メソッドを追加
- 優先度: 高

### タスク2: Model層 - 稼働時間計算ロジックの修正

- ファイル: `src/models/TimecardRepository.ts`
- 内容: `calculateWorkingTimeForDate()` メソッドを修正
  - 検証ロジックを呼び出す
  - 最後がstartの場合は現在時刻までを計算
  - 異常時は `null` を返す
- 優先度: 高

### タスク3: View層 - 赤い棒の表示条件を追加

- ファイル: `src/components/TaskExecutionStackBar.tsx`
- 内容:
  - `calculateWorkingTimeForDate()` の戻り値を `number | null` に対応
  - `null` の場合は赤い棒を非表示にする
- 優先度: 高

### タスク4: テストの追加

- ファイル: `src/models/TimecardRepository.test.ts`
- 内容:
  - `validateTimecardEntries()` のテストケースを追加
  - `calculateWorkingTimeForDate()` の新しい挙動のテストケースを追加
- 優先度: 高

### タスク5: テストの実行と動作確認

- テストを実行して全て通ることを確認
- 実際にアプリを起動して以下のパターンを確認:
  1. 正常なstart-endペアのみ → 赤い棒が表示される
  2. 最後がstartで終わる → 現在時刻までの赤い棒が表示される
  3. start/endが異常な順序 → 赤い棒が表示されない
  4. エントリが存在しない → 赤い棒が表示されない
- 優先度: 高

## 影響範囲

### 変更ファイル

1. `src/models/TimecardRepository.ts` - 検証・計算ロジックの追加・修正
2. `src/components/TaskExecutionStackBar.tsx` - 表示条件の追加
3. `src/models/TimecardRepository.test.ts` - テストケースの追加

### 影響するコンポーネント

- `TaskExecutionStackBar` コンポーネント（赤い棒の表示）
- `DateGroupedTodoList` コンポーネント（TaskExecutionStackBarを使用）

### 後方互換性

- `calculateWorkingTimeForDate()` の戻り値型が `number` から `number | null` に変更
- View層のみが呼び出し元なので、影響範囲は限定的

## 注意事項

1. **現在時刻の取得**
   - `calculateWorkingTimeForDate()` 内で `new Date()` を使用して現在時刻を取得
   - テスト時はモックが必要になる可能性がある

2. **日付を跨ぐケース**
   - startが前日でendが翌日の場合は想定外（仕様上、各日付のエントリは独立している）
   - 現在の設計では考慮不要

3. **タイムゾーン**
   - `new Date()` はローカルタイムゾーンで動作
   - タイムカードのtimeはJST文字列（"YYYY-MM-DD HH:mm:ss"）
   - `new Date(entry.time)` でパース可能（ローカルタイムとして解釈される）

4. **負の時間差**
   - endがstartより前の時刻の場合、負の値になる
   - 現状の実装では検証していないが、今回の検証ロジックでも対応しない
   - 将来的には時刻の順序も検証する必要がある可能性

## 完了条件

- [ ] タスク1: `validateTimecardEntries()` メソッドが実装されている
- [ ] タスク2: `calculateWorkingTimeForDate()` メソッドが修正されている
- [ ] タスク3: `TaskExecutionStackBar.tsx` で赤い棒の表示条件が実装されている
- [ ] タスク4: テストケースが追加されている
- [ ] タスク5: すべてのテストが通る
- [ ] タスク5: 実際のアプリで動作確認が完了している

## 実装順序

1. タスク1 → タスク4（検証ロジックのテスト）
2. タスク2 → タスク4（稼働時間計算のテスト）
3. タスク5（全テスト実行）
4. タスク3（View層の修正）
5. タスク5（動作確認）
